
# Docker 컨테이너에서 실행되는 프로세스를 관리하기 위한 간단한 도구

## **왜 `dumb-init`이 필요한가?**

컨테이너 내에서 작동하는 프로세스는 종종 PID 1로 실행됩니다. UNIX 시스템에서 PID 1은 특별한 책임이 있습니다. 그것은 종료되지 않는 자식 프로세스를 "재활용"해야 합니다. 이것을 하지 않으면 종료되지 않은 자식 프로세스들은 "고아" 상태로 남게 되고, 이는 리소스 낭비를 초래할 수 있습니다.

그러나 많은 프로그램(예: Node.js)은 PID 1로서의 이러한 책임을 적절히 다루도록 설계되지 않았습니다. 그 결과, 신호 처리나 자식 프로세스 관리와 같은 문제들이 발생할 수 있습니다.

`dumb-init`은 이런 문제들을 해결하기 위해 만들어졌습니다. PID 1로서 실행되면서, 신호 전달 및 자식 프로세스 관리와 같은 문제들을 올바르게 처리하도록 설계되었습니다.

## **`ENTRYPOINT`의 사용**

`ENTRYPOINT ["/usr/bin/dumb-init", "--"]`는 `dumb-init`을 컨테이너의 초기화 프로세스로 설정하는 역할을 합니다. 그 다음에 오는 `CMD`의 명령어가 `dumb-init`에 의해 관리되는 실제 실행되는 프로세스가 됩니다.

이렇게 함으로써, `node dist/src/main.js`와 같은 실제 애플리케이션 프로세스는 `dumb-init`에 의해 제대로 관리될 수 있습니다.

요약하자면, `dumb-init`은 컨테이너 환경에서 프로세스의 제대로 된 생명주기 관리와 신호 처리를 도와주는 도구입니다.

---

1. **좀비 프로세스 문제**:

   Docker 컨테이너에서 주 프로세스(PID 1)로 실행되는 애플리케이션이 자식 프로세스를 생성하고, 이 자식 프로세스가 종료될 때, 해당 프로세스의 상태 정보는 커널에 의해 유지됩니다. 일반적으로 이런 종료된 프로세스의 정보는 init 시스템(예: systemd)에 의해 회수되지만, Docker 컨테이너 내에서는 이런 init 시스템이 동작하지 않기 때문에 이 정보들은 좀비 프로세스로 남게 됩니다. `dumb-init`는 이러한 좀비 프로세스를 회수하는 역할을 합니다.

2. **시그널 포워딩**:

   Docker 컨테이너에서 실행되는 주 프로세스(PID 1)는 OS로부터 시그널을 직접 받게 됩니다. 그러나 많은 애플리케이션들은 PID 1로 실행되었을 때 이러한 시그널을 올바르게 처리하지 않습니다. 예를 들어, **`SIGTERM`** 시그널을 받았을 때, 컨테이너 내의 모든 프로세스를 종료시키는 것이 바람직한데, 많은 애플리케이션들은 이를 처리하지 않습니다. `dumb-init`는 이러한 시그널을 받아서 컨테이너 내의 모든 프로세스에게 올바르게 전달하는 역할을 합니다.

3. **간단하고 가벼움**:
   
   `dumb-init`은 위의 두 가지 주요 기능만을 제공하는 매우 간단한 도구입니다. 그래서 오버헤드가 거의 없이 컨테이너에 추가할 수 있습니다.


`ENTRYPOINT ["/usr/bin/dumb-init", "--"]`는 컨테이너가 시작될 때 `dumb-init`을 주 프로세스로 실행하도록 설정합니다. 그리고 `--` 뒤에 오는 커맨드나 인자들은 `dumb-init`에 의해 실행될 실제 애플리케이션으로 전달됩니다.

요약하면, `dumb-init`은 Docker 컨테이너 내에서 좀비 프로세스 문제를 해결하고, OS 시그널을 올바르게 포워딩하여 애플리케이션의 안정성과 유지 관리성을 향상시키기 위해 사용됩니다.

---

### **1. 시그널 처리 문제**

아래와 같이 간단한 Node.js 애플리케이션을 생각해봅시다:

```jsx
javascriptCopy code
// server.js
const http = require('http');

const requestListener = (req, res) => {
  res.writeHead(200);
  res.end('Hello, World!');
}

const server = http.createServer(requestListener);
server.listen(8080, () => {
  console.log('Server is running...');
});

```

이 애플리케이션을 Docker 컨테이너로 실행하면 Node.js 프로세스는 PID 1로 실행됩니다. 만약 컨테이너에 종료 시그널을 보내면, Node.js 프로세스는 그 시그널을 적절히 처리하지 않을 수 있습니다. 이는 컨테이너가 예상보다 늦게 종료되는 결과를 초래할 수 있습니다.

### **2. 좀비 프로세스 문제**

다음은 자식 프로세스를 생성하는 간단한 Node.js 애플리케이션입니다:

```jsx
javascriptCopy code
const { spawn } = require('child_process');

setInterval(() => {
  const child = spawn('echo', ['Hello']);
  child.on('exit', (code) => {
    console.log('Child process exited with code', code);
  });
}, 1000);

```

이 애플리케이션은 매 초마다 **`echo`** 명령을 실행하는 자식 프로세스를 생성합니다. 만약 이 애플리케이션을 PID 1로 실행하는 Docker 컨테이너에서 실행하면, 자식 프로세스들은 종료되었음에도 불구하고 컨테이너에서는 좀비 프로세스로 남게 됩니다. 왜냐하면 PID 1로 실행되는 프로세스는 시스템에서 자식 프로세스의 상태를 회수하는 역할을 해야 하지만, 일반 애플리케이션은 이 역할을 수행하지 않기 때문입니다.

### **`dumb-init`의 역할**

이러한 문제들을 해결하기 위해 **`dumb-init`**를 사용합니다. **`dumb-init`**는 컨테이너에서 PID 1로 실행되며, 시그널 처리와 좀비 프로세스 회수와 같은 PID 1의 역할을 적절히 수행합니다.

따라서, 위의 Node.js 애플리케이션을 **`dumb-init`**과 함께 Docker 컨테이너에서 실행하면, 시그널 처리와 좀비 프로세스 문제가 발생하지 않습니다. **`dumb-init`**은 받은 시그널을 Node.js 프로세스로 전달하고, 종료된 자식 프로세스의 상태도 적절히 회수합니다.

이렇게 **`dumb-init`**을 사용하면 Docker 컨테이너에서 발생할 수 있는 PID 1 관련 문제를 간단하게 해결할 수 있습니다.

---

1. **자식 프로세스 생성:**
   어떤 프로세스는 다른 프로세스를 생성할 수 있습니다. 생성된 프로세스를 '자식 프로세스'라고 하고, 생성한 프로세스를 '부모 프로세스'라고 합니다.
2. **종료 상태:**
   프로세스가 종료될 때 종료 상태를 반환합니다. 이 종료 상태는 부모 프로세스가 참조할 수 있습니다. 즉, 부모 프로세스는 자식 프로세스가 어떻게 종료되었는지를 확인할 수 있습니다.
3. **좀비 프로세스:**
   자식 프로세스가 종료된 후 그의 종료 상태를 부모 프로세스가 아직 참조하지 않았다면, 그 자식 프로세스는 '좀비 프로세스' 상태가 됩니다. 좀비 프로세스는 자원을 해제하지 않고 시스템에 남아있게 됩니다.
4. **자식 프로세스의 상태 회수:**
   부모 프로세스는 자식 프로세스의 종료 상태를 확인하면 (이를 회수라고 합니다) 그 자식 프로세스는 시스템에서 완전히 제거됩니다.

일반적으로, 부모 프로세스는 자식 프로세스의 종료 상태를 적절히 확인하고 회수하는 역할을 합니다. 그러나 Docker 컨테이너 내에서 일반 애플리케이션 (예: Node.js)이 PID 1로 실행될 때, 그 애플리케이션은 자식 프로세스의 종료 상태를 확인하고 회수하는 역할을 수행하지 않습니다. 왜냐하면 일반 애플리케이션은 이러한 동작을 기대하지 않기 때문입니다.

그 결과, Docker 컨테이너 내에서 생성된 자식 프로세스들은 좀비 프로세스가 되어 시스템에 남아있게 됩니다. 이런 상황은 원치 않는 자원의 소모와 여러 문제를 일으킬 수 있습니다.

**`dumb-init`**은 이런 문제를 해결하기 위해 만들어졌습니다. **`dumb-init`**은 PID 1로 실행되면서 자식 프로세스의 종료 상태를 적절히 확인하고 회수하는 역할을 합니다. 따라서, **`dumb-init`**을 사용하면 Docker 컨테이너 내에서 좀비 프로세스가 생성되는 것을 방지할 수 있습니다.

---

## 왜 일반 애플리케이션은 이러한 동작을 기대하지 않는가에 대해서..

일반 애플리케이션들은 특정한 목적과 기능성을 가지고 설계됩니다. 예를 들면, 웹 서버 애플리케이션은 HTTP 요청을 처리하는 것, 데이터베이스 애플리케이션은 데이터의 저장 및 조회를 관리하는 것 등의 기능에 중점을 둡니다.

이러한 애플리케이션들은 일반적으로 다음과 같은 이유로 자식 프로세스의 종료 상태를 회수하는 역할에 대해 고려하지 않습니다:

1. **특정 목적:** 대부분의 애플리케이션은 특정한 기능을 수행하기 위해 설계되었습니다. 이 기능 외의 일반적인 시스템 관리와 관련된 역할을 하는 것은 그 애플리케이션의 주요 목적이 아닙니다.
2. **운영 체제의 도움:** 전통적인 운영 체제 환경에서, 프로세스의 관리와 관련된 역할은 주로 운영 체제가 담당합니다. 즉, 애플리케이션은 자신이 생성한 자식 프로세스의 종료 상태를 운영 체제가 회수하도록 기대할 수 있습니다.
3. **환경의 예상:** 대부분의 애플리케이션은 PID 1로 실행될 것이라고는 예상하지 않습니다. 따라서, PID 1로 실행될 때 필요한 특별한 동작을 고려하지 않을 수 있습니다.

Docker와 같은 컨테이너 환경에서는 이러한 전제 조건들이 달라집니다. 컨테이너는 격리된 환경에서 동작하기 때문에, 컨테이너 내의 애플리케이션이 PID 1로 실행될 수 있습니다. 따라서, 컨테이너 환경에서는 이러한 특별한 사항들을 고려해야 하는데, **`dumb-init`**와 같은 도구들이 이러한 문제를 해결하기 위해 나온 것입니다.


# keyword
- [prosess signal list](https://www-uxsup.csx.cam.ac.uk/courses/moved.Building/signals.pdf)